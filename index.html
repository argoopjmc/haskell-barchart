<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="date" content="" />
  <link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div id="TOC"
><ul
  ><li
    ><a href="#install"
      >install</a
      ></li
    ><li
    ><a href="#use"
      >use</a
      ><ul
      ><li
	><a href="#flags"
	  >flags</a
	  ></li
	><li
	><a href="#criterion"
	  >criterion</a
	  ></li
	><li
	><a href="#progression"
	  >progression</a
	  ></li
	></ul
      ></li
    ><li
    ><a href="#contribute"
      >contribute</a
      ><ul
      ><li
	><a href="#limitations"
	  >limitations</a
	  ></li
	><li
	><a href="#thanks"
	  >thanks</a
	  ></li
	></ul
      ></li
    ><li
    ><a href="#contact"
      >contact</a
      ></li
    ></ul
  ></div
>
<img id="logo" src="logo.png" />
<p
>barchart is a command-line program for generating bar charts from CSV files. It has special support for creating charts from data generated by the Haskell benchmarking tools <a href="http://hackage.haskell.org/package/criterion"
  >criterion</a
  > and <a href="http://hackage.haskell.org/package/progression"
  >progression</a
  >. barchart can create PNG, SVG, PDF, and PS files using the Haskell <a href="http://code.haskell.org/diagrams/"
  >Diagrams</a
  > library for rendering and, hence, depends on a Haskell binding to Cairo which is part of <a href="http://www.haskell.org/gtk2hs/"
  >Gtk2Hs</a
  >.</p
><div id="install"
><h1
  ><a href="#TOC"
    >install</a
    ></h1
  ></div
><div id="use"
><h1
  ><a href="#TOC"
    >use</a
    ></h1
  ><p
  >Bar charts can be created from CSV files using the <code
    >barchart</code
    > command-line utility. For example, if you want to track how many hours you practice playing the guitar on each day of the week, you can create a file <code
    >guitar.csv</code
    > with the following contents:</p
  ><pre
  ><code
    >Mon,1.2
Tue,0.3
Wed,2.1
Thu,0.9
Fri,1.1
Sat,3.2
Sun,3.1
</code
    ></pre
  ><p
  >The call</p
  ><pre
  ><code
    ># barchart --title=&quot;Practice hours&quot; guitar.csv 
</code
    ></pre
  ><p
  >creates a file <code
    >guitar.png</code
    > which looks like this:</p
  ><p
  ><img src="http://sebfisch.github.com/haskell-barchart/examples/guitar.png" alt="Practice hours"
     /></p
  ><p
  >Each bar is labeled with a weekday and has an associated practice hour. The chart is scaled automatically such that the largest bar spans the (configurable, see below) height of the chart. The <code
    >--title</code
    > flag passed to <code
    >barchart</code
    > in the above call is optional. If you do not supply one, then barchart uses the basename of the CSV file as title of the chart.</p
  ><p
  >If you want to track practice hours over multiple weeks, you can create a file with a <em
    >mean</em
    >, <em
    >minimal</em
    >, and <em
    >maximal</em
    > values for each day of the week:</p
  ><pre
  ><code
    >Mon,1.2,0.9,1.7
Tue,0.3,0.1,0.5
Wed,2.1,1.5,2.5
Thu,0.9,0.4,1.0
Fri,1.1,1.0,1.2
Sat,3.2,1.5,5.2
Sun,3.1,2.3,4.2
</code
    ></pre
  ><p
  >Calling <code
    >barchart</code
    > in the <code
    >interval</code
    > mode</p
  ><pre
  ><code
    ># barchart intervals --title=&quot;Mean practice hours&quot; guitar-mean.csv
</code
    ></pre
  ><p
  >produces the following bar chart:</p
  ><p
  ><img src="http://sebfisch.github.com/haskell-barchart/examples/guitar-mean.png" alt="Mean practice hours"
     /></p
  ><p
  >In this chart, each bars represents the mean practice hour for a day of the week and the minimum and maximum values are depicted with intervals on the right edge of a bar.</p
  ><p
  >If you want to compare your practice hours for each day of the week and split it by months, you can create a CSV file like this:</p
  ><pre
  ><code
    >Mon,1.2,2.1,1.7
Tue,0.6,0.7,0.8
Wed,2.1,1.2,2.5
Thu,0.9,1.5,1.7
Fri,1.1,1.3,0.7
Sat,3.2,1.7,4.3
Sun,3.1,3.2,2.1
</code
    ></pre
  ><p
  >We can use <code
    >barchart</code
    > (in the default mode)</p
  ><pre
  ><code
    ># barchart --title=&quot;Practice hours per month&quot; --division=&quot;Jan Feb Mar&quot; guitar-months.csv
</code
    ></pre
  ><p
  >to create the following diagram:</p
  ><p
  ><img src="http://sebfisch.github.com/haskell-barchart/examples/guitar-months.png" alt="Practice hours by month"
     /></p
  ><p
  >Each bar is divided into different blocks which all have an associated amount of practice hours. Green blocks represent practice hours in January, red blocks in February, and blue blocks represent practice hours in March. The block labels are given to <code
    >barchart</code
    > via the <code
    >--division</code
    > flag. You can also draw multiple blocks per bar in <code
    >interval</code
    > mode but then three values (<em
    >mean</em
    >,<em
    >min</em
    >,<em
    >max</em
    >) are used for each block. Hence, if you want to depict mean practice times with deviations for January, February, and March, you must create a CSV file where each day of the week is followed by nine practice times.</p
  ><div id="flags"
  ><h2
    ><a href="#TOC"
      >flags</a
      ></h2
    ><p
    >The <code
      >barchart</code
      > program can be configured using command-line flags. We can use the <code
      >--help</code
      > flag to print a summary:</p
    ><pre
    ><code
      ># barchart --help
Bar Chart 0.1

barchart [blocks] [FLAG] [FILE]

barchart intervals [FLAG] [FILE]

barchart criterion [FLAG] [FILE]

     --summary               Show benchmark summary (default)
  -s --summary-comparison    Compare different benchmark summaries
  -b --benchmark-comparison  Compare different benchmarks

barchart progression [FLAG] [FILE]

  -s --summary-comparison    Breakdown chart by benchmark summary (default)
  -b --benchmark-comparison  Breakdown chart by benchmarks

Common flags:
  -? --help[=FORMAT]         Show usage information (optional format)
  -V --version               Show version information
  -v --verbose               Higher verbosity
  -q --quiet                 Lower verbosity
  -o --out-file=FILE         Name of generated file
  -t --title=STRING          Title of bar chart
  -x --xlabel=STRING         Label of x axis
  -y --ylabel=STRING         Label of y axis
  -g --guess-file-type       Guess output file type by name (default)
     --png                   Generate .png file
     --svg                   Generate .svg file
     --pdf                   Generate .pdf file
     --ps                    Generate .ps file
  -d --division=STRINGS      Labels separated by whitespace
  -c --colors=STRINGS        Color names separated by whitespace
  -w --width=NUM             Width of generated bar chart (default=600)
  -h --height=NUM            Height of generated bar chart (default=300)
  -l --label-size=NUM        Font size used for labels (default=12)
     --bar-width=FLOAT       Bar width between 0 and 1 (default=0.3)
</code
      ></pre
    ><p
    ><code
      >barchart</code
      > can be run in different modes. We have already seen the default (<code
      >blocks</code
      >) mode and the <code
      >intervals</code
      > mode. The <code
      >criterion</code
      > and <code
      >progression</code
      > modes are described below. Most command-line flags are self explanatory. Apart from what we have seen in the example above, the following options are particularly interesting:</p
    ><ul
    ><li
      ><p
	><code
	  >--xlabel</code
	  > and <code
	  >--ylabel</code
	  > label the axis of the coordinate system.</p
	></li
      ><li
      ><p
	><code
	  >--colors</code
	  > change the colors of the different blocks of a bar. You can use all color names listed in the <a href="http://www.w3.org/TR/SVG11/types.html#ColorKeywords"
	  >SVG 1.1 Specification</a
	  >. If you specify fewer colors than there are blocks, then colors are reused in a cyclic fashion. The default value for this argument is <code
	  >--colors=&quot;seagreen firebrick     midnightblue&quot;</code
	  >.</p
	></li
      ><li
      ><p
	><code
	  >--width</code
	  > and <code
	  >--height</code
	  > specify the dimensions of the generated <em
	  >chart</em
	  >. The generated <em
	  >picture</em
	  > is a little larger because of the title and bar labels. If you want to draw a chart with many bars, you should increase the width compared to the height or tweak the bar width.</p
	></li
      ><li
      ><p
	><code
	  >--bar-width</code
	  > is a value between 0.0 and 1.0 hat specifies how thick the bars are compared to the bar distance. With a value of <code
	  >1.0</code
	  > the bars are drawn directly next to each other, a value of 0.0 would draw bars that are so thin that you cannot see them.</p
	></li
      ></ul
    ></div
  ><div id="criterion"
  ><h2
    ><a href="#TOC"
      >criterion</a
      ></h2
    ><p
    ><a href="http://hackage.haskell.org/package/criterion"
      >criterion</a
      > is a Haskell tool for statistically robust benchmarking that can generate graphs which, for example, depict the densities of execution times. criterion can also generate a CSV file summarising all benchmarks but does not provide means to visualise these summaries.</p
    ><p
    >We can use <code
      >barchart</code
      > in <code
      >criterion</code
      > mode to draw graphs based on the summary files generated by criterion. To demonstrate the criterion mode, we write a small Haskell program that benchmarks a simple definition of the <a href="http://en.wikipedia.org/wiki/Factorial"
      >factorial</a
      > function:</p
    ><pre
    ><code
      >import Criterion.Main

main = defaultMain [bgroup &quot;fac&quot; [bench (show n) (nf product [1..n]) | n &lt;- ns]]
 where ns = [10^4 * k | k &lt;- [1,2,3]] :: [Integer]
</code
      ></pre
    ><p
    >We can compile this program, generate a benchmark summary using criterion, and visualise it using barchart as follows:</p
    ><pre
    ><code
      ># ghc -O2 --make factorial
# ./factorial --summary=factorial.csv
# barchart criterion factorial.csv
</code
      ></pre
    ><p
    >These three calls generate a bar chart with one bar for each benchmark whose size is proportional to the corresponding run time.</p
    ><p
    ><img src="http://sebfisch.github.com/haskell-barchart/examples/factorial.png" alt="fac"
       /></p
    ><p
    >We can now modify the program to use an explicitly recursive definition of the fibonacci function to see whether this affects the run times.</p
    ><pre
    ><code
      >fac 0 = 1
fac n = n * fac (n-1)
</code
      ></pre
    ><p
    >After generating another summary file <code
      >factorial2.csv</code
      > we could generate another bar chart to visualise it and view both charts side by side to compare the run times of the different implementations of the fibonacci function. However, instead of generating two different charts we can also generate a single chart that combines information from multiple benchmark summaries.</p
    ><pre
    ><code
      ># barchart criterion --summary-comparison factorial.csv factorial2.csv
</code
      ></pre
    ><p
    >We can pass as many summary files as we like and barchart will draw a bar for each summary file with blocks representing the different benchmarks.</p
    ><p
    ><img src="http://sebfisch.github.com/haskell-barchart/examples/fac-summaries.png" alt="fac-summaries"
       /></p
    ><p
    >We can see clearly that the original implementation using <code
      >product</code
      > is faster than the explicitly recursive definition of the factorial function. Instead of drawing different bars for different summaries, barchart can also draw different bars for the different benchmarks with blocks for the summaries.</p
    ><p
    ><img src="http://sebfisch.github.com/haskell-barchart/examples/fac-benchmarks.png" alt="fac-benchmarks"
       /></p
    ><p
    >This is less useful for comparing different implementations but useful to compare the different benchmarks using all implementations at once.</p
    ></div
  ><div id="progression"
  ><h2
    ><a href="#TOC"
      >progression</a
      ></h2
    ><p
    ><a href="http://hackage.haskell.org/package/progression"
      >progression</a
      > is an alternative tool to depict criterion’s benchmark results. It generates charts similar to the summary comparisons discussed above but draws bars for different benchmarks next to each other rather than as boxes on top of each other in a single bar. Drawing the results of all benchmarks for a specific implementation on top of each other lets you see immediately, which implementation is the fastest <em
      >in total</em
      > because the total height of the bar is the sum of all benchmarks for the corresponding implementation. However, progression provides features that barchart does not provide such as normalising run times and show them as percentages. Hence, the barchart program has a <code
      >progression</code
      > mode to generate bar charts from CSV files generated by progression.</p
    ><p
    >We can alter the factorial program as follows to generate progression’s data:</p
    ><pre
    ><code
      >import Criterion
import Progression.Main

main = defaultMain (bgroup &quot;fac&quot; [bench (show n) (nf fac n) | n &lt;- ns])
 where ns = [10^4 * k | k &lt;- [1,2,3]] :: [Integer]

fac 0 = 1
fac n = n * fac (n-1)
</code
      ></pre
    ><p
    >We do not need to change the fibonacci function itself because we won’t execute benchmarks using progression. We only generate a comparison of the previous benchmarks:</p
    ><pre
    ><code
      ># mv factorial.csv bench-factorial.csv
# mv factorial2.csv bench-factorial2.csv
# ./factorial --mode=graph --compare=factorial,factorial2
</code
      ></pre
    ><p
    >progression wants the summary files to have specific names, hence, we rename them appropriately before generating a graph. The progression tool generates two files <code
      >plot.csv</code
      > and <code
      >plot.png</code
      >. Here, we are not interested in the generated PNG file but pass the CSV file to the barchart program in progression mode.</p
    ><pre
    ><code
      ># barchart progression --division=&quot;product recursive&quot; plot.csv
</code
      ></pre
    ><p
    >As the CSV file generated by progression does not include information of the names of the summary files, we provide labels using the <code
      >--division</code
      > flag. The generated bar chart loooks like this:</p
    ><p
    ><img src="http://sebfisch.github.com/haskell-barchart/examples/progression-summaries.png" alt="progression-summaries"
       /></p
    ><p
    >The run times of the first implementation are normalised to 100% and the run times of the second implementation are depicted relative to the first. Like in <code
      >criterion</code
      > mode we can also flip the axis in <code
      >progression</code
      > mode.</p
    ><pre
    ><code
      ># barchart progression --benchmark-comparison --division=&quot;product recursive&quot; plot.csv
</code
      ></pre
    ><p
    >Now the first benchmark is normalised to 100% in each bar so this diagram is of questionable use.</p
    ><p
    ><img src="http://sebfisch.github.com/haskell-barchart/examples/progression-benchmarks.png" alt="progression-benchmarks"
       /></p
    ></div
  ></div
><div id="contribute"
><h1
  ><a href="#TOC"
    >contribute</a
    ></h1
  ><p
  >The source code is on <a href="http://github.com/sebfisch/haskell-barchart"
    >GitHub</a
    > so you can create or vote on <a href="http://github.com/sebfisch/haskell-barchart/issues"
    >issues</a
    > to ask for extensions or fork this project to write extensions yourself.</p
  ><div id="limitations"
  ><h2
    ><a href="#TOC"
      >limitations</a
      ></h2
    ><p
    >Currently, barchart does not support negative quantities and draws weird bars if you use them anyway. Also, the legend for blocks is sometimes drawn suboptimally. I guess I made a mistake but I cannot find it.</p
    ></div
  ><div id="thanks"
  ><h2
    ><a href="#TOC"
      >thanks</a
      ></h2
    ><p
    >I would not have written this program without the <a href="http://code.haskell.org/diagrams/"
      >Diagrams</a
      > library by Brent Yorgey and the <a href="http://community.haskell.org/~ndm/cmdargs/"
      >CmdArgs</a
      > package by Neil Mitchell.</p
    ></div
  ></div
><div id="contact"
><h1
  ><a href="#TOC"
    >contact</a
    ></h1
  ><p
  >For questions or feedback email <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#x73;&#x65;&#98;&#102;&#64;&#x69;&#110;&#102;&#x6f;&#114;&#x6d;&#x61;&#116;&#x69;&#x6b;&#46;&#x75;&#110;&#x69;&#x2d;&#x6b;&#x69;&#x65;&#108;&#46;&#100;&#x65;">&#x53;&#x65;&#98;&#x61;&#x73;&#116;&#x69;&#x61;&#110;&#32;&#70;&#x69;&#x73;&#x63;&#104;&#x65;&#114;</a>.</p
  ></div
>
</body>
</html>

